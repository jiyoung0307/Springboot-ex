* 클라이언트 : 서비스를 사용하는 프로그램 또는 컴퓨터
* 서버 : 서비스를 제공하는 프로그램 또는 컴퓨터

* hello.html
- localhost:8080으로만 접속하면 에러 페이지가 뜸
- 그러나 localhost:8080/hello.html을 붙여주면 원하는 화면을 볼 수 있음
- 이는 웹 브라우저(클라이언트)에서 요청한 hello.html 파일을 스프링 부트(서버)가 보여줬기 때문임
- hello.html은 서버에 요청하는 파일을 의미함
- 이렇게 파일을 직접 지정할 경우 스프링 부트는 기본적으로 src > main > resources > static 디렉터리에서 파일을 찾음

* 뷰 템플릿
- 화면을 담당하는 기술로, 웹 페이지를 하나의 틀로 만들고 여기에 변수를 삽입해 서로 다른 페이지로 보여 줌

* 컨트롤러(Controller)
- 클라이언트 요청에 따라 서버에서 이를 처리하는 역할

* 모델(Model)
- 데이터를 관리하는 역할

* MVC 패턴(Model-View-Controller Pattern)
- 웹 페이지를 화면에 보여 주고(View), 클라이언트의 요청을 받아 처리하고(Controller), 데이터를 관리하는(Model) 역할을 나누는 기법

* mustache
- 뷰를 만드는 도구, 뷰 템플릿 엔진을 의미
- mustache 외의 템플릿 엔진으로는 타임리프, JSP가 있음

* controller 생성 후 실행
1. controller 패키지 생성
2. controller.java  파일 생성
3. @Controller 작성
4. 메소드 작성

* 어노테이션(annotation)
- 소스 코드에 추가해 사용하는 메타 데이터의 일종

* 메타 데이터
- 프로그램에서 처리해야 할 데이터가 아니라 컴파일 및 실행 과정에서 코드를 어떻게 처리해야 할지 알려 주는 추가 정보

* @GetMapping
- 페이지를 반환해 달라는 URL 요청을 접수하는 부분

* Model은 컨트롤러의 메소드에서 매개변수로 받아옴

* Model 패키지가 임포트됐다면 모델을 통해 변수를 등록할 수 있음
- 모델에서 변수를 등록할 때는 addAttribute() 사용

* 웹 서비스는 클라이언트의 요청에 대한 서버의 응답으로 동작함
- 스프링 부트는 서버의 역할을 함
- 컨트롤러가 클라이언트의 요청을 받고, 뷰가 최종 페이지를 만들고, 모델이 최종 페이지에 쓰일 데이터를 뷰에 전달함.

* 템플릿화한다 = 코드를 하나의 틀로 만들어 변수화한다

* 폼 데이터(form data) : <form> 태그에 실려 전송되는 데이터
- <form> 태그는 웹 브라우저에서 서버로 데이터를 전송할때 사용함
- <form> 태그도 데이터를 전송할 때 어디로(where), 어떻게(how) 보내지 등을 적어서 보낼 수 있음
- <form> 태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받음 = DTO
- DTO로 받은 데이터는 최종적으로 DB에 저장됨

3.2.3 폼 데이터 전송하기
- <form> 태그에 어디로 보낼지는 action 속성으로, 어떻게 보낼지는 method 속성으로 설정함

* action : URL 연결 주소를 적음. localhost:8080/articles/create 페이지로 폼 데이터를 보낸다는 의미
* method : 속성 값으로 get과 post 2가지를 설정할 수 있음

3.2.4 폼 데이터 받기
- 서버의 컨트롤러가 이 정보를 조합해서 사용자가 전송한 폼 데이터를 받도록 함
1. 컨트롤러에 메소드 추가 및 return 값 설정
2. URL 요청을 받아와야 함. 뷰 페이지에서 폼 데이터를 post 방식으로 전송했으므로 컨트롤러에서 받을 때도 @PostMapping으로 받아야함.
이때 괄호 안에는 URL 주소를 넣어야 함

3.2.5 DTO 만들기
- 컨트롤러에서 폼 데이터를 만들 때 DTO(Data Transfer Object)에 담음
=> 폼 데이터를 받아 올 그릇 = DTO

1) 필드 작성
2) 생성자 작성(전송받은 제목과 내용을 필드에 저장하는 생성자 추가)
3) toString(폼 데이터를 잘 받아왔는지 확인하는 용도)

3.2.6 폼 데이터를 DTO에 담기
- 전송받은 폼 데이터를 DTO에 담아보자
- ArticleFormDTO 타입의 formDTO 객체를 매개변수로 선언

    @PostMapping("/articles/create")
    public String createArticle(ArticleFormDTO formDTO) {
        System.out.println("formDTO.toString() ==> " + formDTO.toString());

3.2.7 입력 폼과 DTO 필드 연결하기
- DTO에서 선언한 필드에 값이 들어가려면 뷰 입력 폼에 필드명을 지정해줘야 함
- 그래야 해당 입력 폼이 DTO의 필드와 연결됨
- ex) input의 name / textarea의 name
- DTO 필드명과 동일한 이름을 name 속성 값으로 써 주면 입력 폼에서 작성한 데이터가 DTO의 해당 필드와 연결됨

3.3
* 데이터베이스 = 데이터를 관리하는 창고
* JPA(Java Persistance API)란 자바 언어로 DB에 명령을 내리는 도구로, 데이터를 객체 지향적으로 관리할 수 있게 해 줌.

* 엔티티 : 자바 객체를 DB가 이해할 수 있게 만든 것으로, 이를 기반으로 테이블이 만들어짐
* 리파지터리 : 엔티티가 DB 속 테이블에 저장 및 관리될 수 있게 하는 인터페이스

* DTO로 받은 폼 데이터를 DB에 저장하는 방법
1) DTO 엔티티로 변환하기
2) 리파지터리를 이용해 엔티티를 DB에 저장하기

3.3.2 DTO를 엔티티로 변환하기
1) Controller에 URL 요청이 들어왔을 때 폼 데이터를 받아 출력하는 코드가 있으므로 여기에 작성
2) DTO를 앤티티로 변환하기 위해 form 객체의 toEntity()를 호출해서 반환값을 Article 타입의 article 엔티티의 저장
(DTO를 엔티티로 변환하려면 먼저 엔티티 클래스부터 만들어야 함)
3) Article 엔티티 생성
4) toEntity() 메서드 추가
- toEntity()는 DTO인 formDTO 객체를 엔티티 객체로 변환하는 역할
4-1) toEntity()는 폼 데이터를 담은 DTO객체를 엔티티로 변환(return new Article();)
전달값은 Article 클래스의 생성자 형식에 맞춰 작성하면됨

3.3.3 리파지터리로 엔티티를 DB에 저장하기
1) save()는 저장된 엔티티를 반환하므로 Article 타입의 saved라는 객체에 받아옴
2) 필드 선언부에 ArticleRepository 타입의 articleRepository 객체를 선언함

5.2.1 URL 요청 받기
- DB에 저장한 데이터를 웹 페이지에서 보려면 해당 출력 페이지에 접속해야 함
- 그러면 URL 요청이 필요 => Controller에 GetMapping 작성

* @PathVariable은 URL 요청으로 들어온 전달값을 컨트롤러의 매개변수로 가져오는 어노테이션

5.2.2 데이터 조회해 출력하기
* id를 조회해 데이터 가져오기
1) DB에서 데이터를 가져오는 주체는 리파지터리임. 리파지터리의 구현 객체는 @Autowired 어노테이션으로 주입받았음
2) findById()는 JPA의 CrudRepository가 제공하는 메소드로, 특정 엔티티의 id값을 기준으로 데이터를 찾아 Optional 타입으로 반환함
3) 찾은 데이터를 Article 타입의 articleEntity 변수에 저장
4) articleRepository가 findById(id)로 찾은 값을 반환할 때 반환형이 Article이 아니라서 생기는 문제
반환형은 Oprional<Article>임

* orElse(null) : id값으로 데이터를 찾을 때 해당 id 값이 없으면 null을 반환하라는 뜻
데이터를 조회한 결과, 값이 있으면 articleEntity 변수에 값을 넣고 없으면 null을 저장하는 것임

* 모델에 데이터 등록하기
1) 데이터를 모델에 등록하는 이유는 MVC 패턴에 따라 조회한 데이터를 뷰 페이지에서 사용하기 위해서임
2) 모델을 사용하기 위해 메서드의 매개변수로 model 객체를 받아옴
3) 모델에 데이터를 등록할 때는 addAttribute() 사용
model.addAttribute(String name, Object value);    // name이라는 이름으로 value 객체 추가

* 뷰 페이지 반환하기
return "articles/show";

5.3 데이터 목록 조회
- 단일 데이터를 조회할 때는 리파지터리가 엔티티를 반환했다면, 데이터 목록을 조회할 때는 엔티티의 묶음인 리스트를 반환함
- 생성한 메서드에 @GetMapping을 선언해 URL 요청을 받도록 함
- 요청이 들어오면 메서드가 수행되면서 뷰 페이지를 설정하는 코드들이 실행될 것임

5.3.2 데이터 조회해 출력하기
1) 모든 데이터 가져오기
2) 모델에 데이터 등록하기
3) 뷰 페이지 설정하기

* 모든 데이터 가져오기
- DB에서 데이터를 가져오기 위해서를 리파지터리가 필요함
- 리파지터리 입력하고 .findAll() 메서드 선택
- findAll() = 해당 히파지터리에 있는 모든 데이터를 가져오는 메서드

- 데이터의 묶음을 받아오는 것이므로 List<Article>로 설정
- 이렇게 하면 DB에서 조회한 데이터 묶음을 리스트에 담긴 Article 타입으로 가져옴

* 반환 데이터 타입 불일치 문제 해결 방법
1. 메서드가 반환하는 데이터 타입을 사용자가 작성한 데이터 타입으로 캐스팅
2. 사용자가 작성한 데이터 타입을 메서드가 반환하는 데이터 타입으로 수정
3. 메서드의 반환 데이터 타입을 원하는 타입으로 오버라이딩

6.1 링크와 리다이렉트란
* 링크
- 미리 정해 놓은 요청을 간편히 전송하는 기능으로, 보통 페이지 이동을 위해 사용함.
- HTML의 <a> 태그 혹은 <form> 태그로 작성
- 클라이언트가 링크를 통해 어느 페이지로 이동하겠다고 요청하면 서버는 결과 페이지를 응답함

* 리다이렉트
- 서버에서 결과 페이지를 응답하지 않고 재요청하라는 회신을 보내기도 함
- 이럴 때 쓰이는게 리다이렉트
- 클라이언트가 보낸 요청을 마친 후 계속해서 처리할 다음 요청 주소를 재지시함
- 이를 통해 분리된 기능을 하나의 연속적인 흐름으로 연결할 수 있음

