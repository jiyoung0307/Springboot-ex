CREATE
------------------------------------------------------------------------------------
* 폼 데이터를 DTO로 받아 엔티티로 변환한 후 리파지터리를 이용해 DB에 저장
- <form>
- action : URL 주소를 적음(where)
- method : GET, POST(how)
- <form> 태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받음 = DTO
- 입력 폼과 DTO 필드를 연결하려면 뷰에서 name="필드명"

DTO로 받은 form 데이터를 DB에 저장하기
1. DTO를 엔티티로 변환하기
1-1. 엔티티 변수명 = dto 변수명.toEntity
** DTO를 엔티티로 변환하려면 먼저 엔티티 클래스부터 만들어야 함

1-2. toEntity()는 DTO인 form 객체를 엔티티 객체로 변환하는 역할
     public 엔티티 toEntity() {
        return new 엔티티(생성자 형식);
     }

2. 리파지터리로 엔티티를 DB에 저장
2-1. 컨트롤러 필드 선언부터 리파지터리 객체 선언
2-2. 리파지터리명.save()를 호출해서 엔티티 저장 (1에서 선언한 엔티티를 저장해 변수명 객체에 반환)
2-3. 리파지터리 만들기(interface)
2-3-1. repusitory extends CrudRepository<T, ID>
2-4. 객체 주입하기
2-4-1. @Autowired
------------------------------------------------------------------------------------
Lombok & Refactoring
@Sf4jl - 로깅할 때 사용, log.info()문으로 출력
@AllArgsConstructor - 클래스 안쪽의 모든 필드를 매개변수로 하는 생성자를 만드는 어노테이션
------------------------------------------------------------------------------------
READ
* 데이터 조회 과정
1. 사용자가 데이터를 조회해 달라고 웹 페이지에서 URL 요청 보냄
2. 서버의 컨트롤러가 요청을 받아 해당 URL에서 찾으려는 데이터 정보를 리파지터리에 전달
3. 리파지터리 정보를 가지고 DB에 데이터 조회 요청
4. DB는 해당 데이터를 찾아 이를 엔티티로 반환
5. 반환된 엔티티는 모델을 통해 뷰 템플릿으로 전달
6. 최종적으로 결과 뷰 페이지가 완성돼 사용자 화면에 출력

------------------------------------------------------------------------------------
* 단일 데이터 조회
1. URL 요청 받기
1-1. 컨트롤러 만들기
1-1-1. @GetMapping
1-1-2. @PathVariable : URL 요청으로 들어온 전달값을 컨트롤러의 매개변수로 가져오는 어노테이션

------------------------------------------------------------------------------------
* 데이터 조회해 출력
1. id를 조회해 DB에서 해당 데이터 가져오기
1-1. @Autowired
1-2. findById()

1-3. 리파지터리가 findById(id)로 찾은 값을 반환할 때 반환형이 엔티티가 아닌 Optional<엔티티>타입
1-3-1. 엔티티를 Optional<엔티티>로 수정하기
       ex) Optional<Article> articleEntity = articleRepository.findById(id);
1-3-2. .orElse(null)
       ex) Article articleEntity = articleRepository.findById(id).orElse(null);
           해당 id가 없으면 null을 반환하라는 뜻 / 데이터를 조회한 결과, 값이 있으면 엔티티변수에 값을 넣고 없으면 null을 저장

1-4. 모델에 데이터 등록하기
- model에 데이터를 등록하는 이유는 MVC 패턴에 따라 조회한 데이터를 뷰 페이지에서 사용하기 위해서임
1-4-1. model에 데이터를 등록할 때는 addAttribute() 메서드 사용

1-5. 뷰 페이지 반환하기
@NoArgsConstructor : 기본 생성자 추가 어노테이션
2. 가져온 데이터 모델에 등록하기
3. 조회한 데이터를 사용자에게 보여 주기 위한 뷰 페이지 만들고 반환하기
------------------------------------------------------------------------------------
* 목록 데이터 조회
1. DB에서 모든 엔티티 데이터 가져오기
1-1. 리파지터리.findAll()
1-1-1. 데이터의 묶음을 받아 오는 것이므로 List<엔티티>로 설정
       DB에서 조회한 데이터 묶음을 리스트에 담긴 엔티티 타입으로 가져옴
** 반환 데이터 타입 불일치 문제 해결 방법
1) 메서드가 반환하는 데이터 타입을 사용자가 작성한 데이터 타입으로 캐스팅(형변환)하기
1-1) Iterable이 가장 상위 인터페이스
ex) Iterable<Article> articleEntityList = articleRepository.findAll();

2) 사용자가 작성한 데이터 타입을 메서드가 반환하는 데이터 타입으로 수정하기
ex) ArrayList<Article> articleEntityList = articleRepository.findAll();

3) 메서드의 반환 데이터 타입을 원하는 타입으로 오버라이딩하기
ArrayList<Article> articleEntityList = articleRepository.findAll();

1-2. 리파지터리에서 CrudRepository를 상속받고 있으니 findAll() 오버라이딩
ex)
    @Override
    ArrayList<Article> findAll();

2. 가져온 엔티티 묶음을 모델에 등록하기
2-1. 가져 온 데이터를 받은 articleList를 뷰 페이지로 전달할 때는 모델을 사용함
2-2. model.addAttribute() 메서드로 전달할 데이터 묶음인 articleEntityList 등록
model.addAttribute("articleList", articleEntityList);

3. 사용자에게 보여 줄 페이지 설정하기
return 뷰 페이지
------------------------------------------------------------------------------------
UPDATE
1. 기존 데이터 불러오기
1-1. 요청 받은 컨트롤러는 해당 글의 id로 DB에서 데이터를 찾아 가져옴
1-2. 컨트롤러는 가져온 데이터를 뷰에서 사용할 수 있도록 모델에 등록
1-3. 모델에 등록된 데이터를 수정 페이지에서 보여줌. 그러면 사용자가 수정할 수 있는 상태가 됨

2. 데이터를 수정해 DB에 반영한 후 결과를 볼 수 있게 상세 페이지로 리다이렉트
2-1. 폼 데이터(수정 요청 데이터)르르 DTO에 담아 컨트롤러에서 받음
2-2. DTO를 엔티티로 변환
2-3. DB에서 기존 데이터를 수정 데이터로 갱신
2-4. 수정 데이터를 상세 페이지로 리다이렉트
------------------------------------------------------------------------------------
DELETE
1. 클라이언트가 HTTP 메서드로 특정 게시글의 삭제를 요청함
2. 삭제 요청을 받은 컨트롤러는 리파지터리를 통해 DB에 저장된 데이터를 찾아 삭제(기존에 데이터가 있는 경우)
3. 삭제가 완료되면 클라이언트를 결과 페이지로 리다이렉트
3-1. 결과 페이지로 리다이렉트할 때 클라이언트에 삭제 완료 메시지 띄워주면 good.
이를 위한 클래스가 RedirectAttributes 객체의 addFlashAttribute()메서드는 리다이레트된 페이지에서 사용할 일회성 데이터를 등록할 수 있은
